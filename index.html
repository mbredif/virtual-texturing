<!DOCTYPE html>
<html>
  <head>
    <meta charset="iso-8859-15">
    <title>Virtual Textures | Example</title>
    <link rel="stylesheet" type="text/css" href="examples/css/main.css">
    <script src="examples/jsm/stats.min.js"></script>
  </head>

  <body>

    <div class="container background">
      <div class="header"></div>
      <div class="content">
        <div id="canvas_container"></div>
      </div>
    </div>

    <script type="module">
      import { APP } from './examples/jsm/Main.js';
      import { PlaneGeometry, FloatType, RedFormat } from './examples/jsm/three.module.js';

      const app = new APP();

      app.start();

      class WMSSource {
        constructor(config) {
          Object.assign(this, config);
          this.base = config.wms + '?Service=WMS&Request=GetMap'
          + '&Version=' + (config.version || '1.3.0')
          + '&Layers=' + config.layer
          + '&Format=' + (config.mimeType || 'image/jpeg')
          + '&CRS=' + config.crs
          + '&Width=' + (this.width+2*this.padding)
          + '&Height='+ (this.height+2*this.padding)
          + '&BBox=';
        }
        getUrl(tile) {
          const bbox = this.bbox;
          const padding = this.padding;
          const w = (bbox[2]-bbox[0]) / (1 << tile.z);
          const h = (bbox[3]-bbox[1]) / (1 << tile.z);
          const x = bbox[0]+w*tile.x;
          const y = bbox[3]-h*tile.y;
          const a = w*padding/this.width;
          const b = h*padding/this.height;
          return this.base+(y-h-b)+','+(x-a)+','+(y+b)+','+(x+w+a);
        }
      }

      class WMTSSource {
        constructor(config) {
          Object.assign(this, config);
          this.base = config.wmts + '?Service=WMTS&Request=GetTile'
          + '&Version=' + (config.version || '1.0.0')
          + '&Layer=' + config.layer
          + '&Format=' + (config.mimeType || 'image/jpeg')
          + '&Style=' + (config.style || 'normal')
          + '&TileMatrixSet=' + config.tileMatrixSet
          + '&TileMatrix=';
        }
        getUrl(tile) {
          if (this.tileMatrixSetLimits) {
            const limits = this.tileMatrixSetLimits[tile.z];
            if(!limits || tile.x < limits.minTileCol || tile.x > limits.maxTileCol || tile.y < limits.minTileRow || tile.y > limits.maxTileRow)
              return undefined;
          }
          return this.base+tile.z+'&TileRow='+tile.y+'&TileCol='+tile.x;
        }
      }

      class IIPSource {
        constructor(config) {
          const scope = this;
          Object.assign(this, config);
          const url = config.iip + '?FIF=' + config.id;
          this.base = url+'&LYR=20&JTL=';
          this.promise = fetch(url + '&obj=IIP,1.0&obj=Max-size&obj=Tile-size&obj=Resolution-number')
          .then((response) => response.text())
          .then((txt) => Object.fromEntries(txt.split(/\r?\n/)
            .map((line) => line.split(':'))
            .filter((line) => line.length == 2)
            .map((entry) => {
              const values = entry[1].split(/\s+/).map((v) => parseInt(v, 10));
              return [entry[0], values];
            })
          ))
          .then((info) => {
            scope.size = info['Max-size'];
            const size = info['Tile-size'];
            scope.minMipMapLevel = 0;
            scope.maxMipMapLevel = info['Resolution-number']-1;
            scope.width = size[0];
            scope.height = size[1];
            scope.numTiles = [];
            for(let z=0; z<=scope.maxMipMapLevel; ++z) {
              const TW = scope.width  << (scope.maxMipMapLevel - z);
              const TH = scope.height << (scope.maxMipMapLevel - z);
              const W = Math.ceil(scope.size[0]/TW);
              const H = Math.ceil(scope.size[1]/TH);
              scope.numTiles[z] = [W, H];
            }
          });
        }
        getUrl(tile) {
          const W = this.numTiles[tile.z][0];
          const H = this.numTiles[tile.z][1];
          if ( tile.x >= W || tile.y >= H ) return null;
          return this.base+tile.z+','+(tile.x+W*tile.y);
        }
      }

      var config = [
        {
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.25,
          source: new WMTSSource({
            version: '1.0.0',
            tileMatrixSet: 'PM',
            wmts: 'https://wxs.ign.fr/decouverte/geoportail/wmts',
            layer: 'ORTHOIMAGERY.ORTHOPHOTOS',
            width: 256,
            height: 256,
            padding: 0,
            minMipMapLevel: 0,
            maxMipMapLevel: 9,
          })
        },
        {
          tileClamp: 0.5,
          pageCount: [32,32],
          tileDeterminationRatio: 0.125,
          source: {
            getUrl(tile) {
              const pageNumber = tile.x + tile.y * ( 1 << tile.z );
              return '/examples/models/terrain/tiles/diffuse/' + tile.z + '-' + pageNumber + ".jpg";
            },
            width: 128,
            height: 128,
            padding: 4,
            minMipMapLevel: 0,
            maxMipMapLevel: 4,
          }
        },
        {
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.125,
          source: new IIPSource({
            iip: 'https://wxs.ign.fr/x7yv499pbcguxhhxh8syehwe/iipsrv.fcgi',
            id: 'DEMAT.PVA/0317-0101/IGNF_PVA_1-0__1944__C0317-0101_1944_106G2481_4026.jp2',
            padding: 0,
          }),
        },
        {
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.1,
          source: new WMSSource({
            wms: 'https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv',
            layer: 'gebco_latest',
            crs: 'EPSG:4326',
            bbox: [-10,40,15,55],
            width: 256,
            height: 256,
            padding: 10,
            minMipMapLevel: 0,
            maxMipMapLevel: 7,
          })
        },
        {
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.1,
          source: new WMTSSource({
            wmts: 'https://wxs.ign.fr/altimetrie/geoportail/wmts',
            layer: 'ELEVATION.ELEVATIONGRIDCOVERAGE.SRTM3',
            tileMatrixSet: 'WGS84G',
            mimeType: 'image/x-bil;bits=32',
            width: 256,
            height: 256,
            padding: 0,
            format: RedFormat,
            type: FloatType,
            minMipMapLevel: 1,
            maxMipMapLevel: 10,
            tileMatrixSetLimits: {
                "1": { "minTileRow": 0, "maxTileRow": 1, "minTileCol": 0, "maxTileCol": 4 },
                "2": { "minTileRow": 0, "maxTileRow": 3, "minTileCol": 0, "maxTileCol": 8 },
                "3": { "minTileRow": 1, "maxTileRow": 6, "minTileCol": 0, "maxTileCol": 16 },
                "4": { "minTileRow": 2, "maxTileRow": 12, "minTileCol": 0, "maxTileCol": 32 },
                "5": { "minTileRow": 5, "maxTileRow": 25, "minTileCol": 0, "maxTileCol": 64 },
                "6": { "minTileRow": 10, "maxTileRow": 51, "minTileCol": 0, "maxTileCol": 128 },
                "7": { "minTileRow": 20, "maxTileRow": 103, "minTileCol": 0, "maxTileCol": 256 },
                "8": { "minTileRow": 41, "maxTileRow": 207, "minTileCol": 0, "maxTileCol": 512 },
                "9": { "minTileRow": 82, "maxTileRow": 415, "minTileCol": 0, "maxTileCol": 1024 },
                "10": { "minTileRow": 164, "maxTileRow": 830, "minTileCol": 0, "maxTileCol": 2048 }
            }
          })
        }
      ];

      var geometry = new PlaneGeometry(100, 100, 100);
      function start(conf) {
        app.load(geometry, conf);
        app.run();
        window.vt = app.virtualTexture;
      }

      const params = new URL(document.location).searchParams;
      const conf = config[parseInt(params.get("config")) || 0];
      if (conf.source.promise) conf.source.promise.then(() => start(conf));
      else           start(conf);

    </script>
  </body>

  </head>
</html>
