<!DOCTYPE html>
<html>
  <head>
    <meta charset="iso-8859-15">
    <title>Virtual Textures | Example</title>
    <link rel="stylesheet" type="text/css" href="examples/css/main.css">
    <script src="examples/jsm/stats.min.js"></script>
  </head>

  <body>

    <div class="container background">
      <div class="header"></div>
      <div class="content">
        <div id="canvas_container"></div>
      </div>
    </div>

    <script type="module">
      import { APP } from './examples/jsm/Main.js';
      import { PlaneGeometry } from './examples/jsm/three.module.js';

      const app = new APP();

      app.start();

      import { FloatType, RedFormat, DataTextureLoader } from '../examples/jsm/three.module.js';
      class XBILLoader extends DataTextureLoader {
      	constructor( manager ) {
      		super( manager );
      	}

        parse( buffer ) {
      		return { data: new Float32Array(buffer) };
        }

      	load( url, onLoad, onProgress, onError, options = {}) {
          const width = options.width || 256;
          const height = options.height || 256;
          const format = options.format || RedFormat;
          const type = options.type || FloatType;
          const internalFormat = options.internalFormat || "R32F";
      		function onLoadCallback( texture, texData ) {
            texture.format = format;
            texture.internalFormat = internalFormat;
            texture.image.width = width;
            texture.image.height = height;
            texture.image.type = type;
      			if ( onLoad ) onLoad( texture, texData );
      		}
      		return super.load( url, onLoadCallback, onProgress, onError );
      	}
      }

      class WMSSource {
        constructor(config) {
          Object.assign(this, config);
          this.base = config.wms + '?Service=WMS&Request=GetMap'
          + '&Version=' + (config.version || '1.3.0')
          + '&Layers=' + config.layer
          + '&Format=' + (config.mimeType || 'image/jpeg')
          + '&CRS=' + config.crs
          + '&Width=' + (this.width+2*this.padding)
          + '&Height='+ (this.height+2*this.padding)
          + '&BBox=';
        }
        getUrl(tile) {
          const bbox = this.bbox;
          const padding = this.padding;
          const w = (bbox[2]-bbox[0]) / (1 << tile.z);
          const h = (bbox[3]-bbox[1]) / (1 << tile.z);
          const x = bbox[0]+w*tile.x;
          const y = bbox[3]-h*tile.y;
          const a = w*padding/this.width;
          const b = h*padding/this.height;
          return this.base+(y-h-b)+','+(x-a)+','+(y+b)+','+(x+w+a);
        }
      }

      class WMTSSource {
        constructor(config) {
          Object.assign(this, config);
          this.base = config.wmts + '?Service=WMTS&Request=GetTile'
          + '&Version=' + (config.version || '1.0.0')
          + '&Layer=' + config.layer
          + '&Format=' + (config.mimeType || 'image/jpeg')
          + '&Style=' + (config.style || 'normal')
          + '&TileMatrixSet=' + config.tileMatrixSet
          + '&TileMatrix=';
        }
        getUrl(tile) {
          return this.base+tile.z+'&TileRow='+tile.y+'&TileCol='+tile.x;
        }
      }

      class IIPSource {
        constructor(config) {
          const scope = this;
          Object.assign(this, config);
          const url = config.iip + '?FIF=' + config.id;
          this.base = url+'&LYR=20&JTL=';
          this.promise = fetch(url + '&obj=IIP,1.0&obj=Max-size&obj=Tile-size&obj=Resolution-number')
          .then((response) => response.text())
          .then((txt) => Object.fromEntries(txt.split(/\r?\n/)
            .map((line) => line.split(':'))
            .filter((line) => line.length == 2)
            .map((entry) => {
              const values = entry[1].split(/\s+/).map((v) => parseInt(v, 10));
              return [entry[0], values];
            })
          ))
          .then((info) => {
            scope.size = info['Max-size'];
            const size = info['Tile-size'];
            scope.maxMipMapLevel = info['Resolution-number']-1;
            scope.width = size[0];
            scope.height = size[1];
            scope.numTiles = [];
            for(let z=0; z<=scope.maxMipMapLevel; ++z) {
              const TW = scope.width  << (scope.maxMipMapLevel - z);
              const TH = scope.height << (scope.maxMipMapLevel - z);
              const W = Math.ceil(scope.size[0]/TW);
              const H = Math.ceil(scope.size[1]/TH);
              scope.numTiles[z] = [W, H];
            }
          });
        }
        getUrl(tile) {
          const W = this.numTiles[tile.z][0];
          const H = this.numTiles[tile.z][1];
          if ( tile.x >= W || tile.y >= H ) return null;
          return this.base+tile.z+','+(tile.x+W*tile.y);
        }
      }

      var config = [
        {
          maxMipMapLevel: 9,
          minMipMapLevel: 0,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.25,
          source: new WMTSSource({
            version: '1.0.0',
            tileMatrixSet: 'PM',
            style: 'normal',
            mimeType: 'image/jpeg',
            wmts: 'https://wxs.ign.fr/decouverte/geoportail/wmts',
            layer: 'ORTHOIMAGERY.ORTHOPHOTOS',
            width: 256,
            height: 256,
            padding: 0,
          })
        },
        {
          minMipMapLevel: 0,
          tileClamp: 0.5,
          pageCount: [32,32],
          tileDeterminationRatio: 0.125,
          source: {
            maxMipMapLevel: 4,
            getUrl(tile) {
              const pageNumber = tile.x + tile.y * ( 1 << tile.z );
              return '/examples/models/terrain/tiles/diffuse/' + tile.z + '-' + pageNumber + ".jpg";
            },
            width: 128,
            height: 128,
            padding: 4,
          }
        },
        {
          minMipMapLevel: 0,
            maxMipMapLevel: 6,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.125,
          source: new IIPSource({
            iip: 'https://wxs.ign.fr/x7yv499pbcguxhhxh8syehwe/iipsrv.fcgi',
            id: 'DEMAT.PVA/0317-0101/IGNF_PVA_1-0__1944__C0317-0101_1944_106G2481_4026.jp2',
            padding: 0
          }),
        },
        {
          maxMipMapLevel: 7,
          minMipMapLevel: 0,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.1,
          source: new WMSSource({
            wms: 'https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv',
            layer: 'gebco_latest',
            crs: 'EPSG:4326',
            bbox: [-10,40,15,55],
            width:256,
            height:256,
            padding:30,
            numTextures: 5
          })
        },
        {
          maxMipMapLevel: 2,
          minMipMapLevel: 0,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.1,
          source: new WMTSSource({
            url: 'https://wxs.ign.fr/altimetrie/geoportail/wmts',
            layer: 'ELEVATION.ELEVATIONGRIDCOVERAGE.SRTM3',
            style: 'normal',
            tileMatrixSet: 'WGS84G',
            mimeType: 'image/x-bil;bits=32',
            width: 256,
            height: 256,
            format: RedFormat,
            type: FloatType,
            internalFormat : "R32F",
            padding: 0
          }),
          loader: new XBILLoader()
        }
      ];

      var geometry = new PlaneGeometry(100, 100, 100);
      function start(conf) {
        app.load(geometry, conf);
        app.run();
        window.vt = app.virtualTexture;
      }

      const params = new URL(document.location).searchParams;
      const conf = config[parseInt(params.get("config")) || 0];
      if (conf.source.promise) conf.source.promise.then(() => start(conf));
      else           start(conf);

    </script>
  </body>

  </head>
</html>
