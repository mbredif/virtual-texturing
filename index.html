<!DOCTYPE html>
<html>
  <head>
    <meta charset="iso-8859-15">
    <title>Virtual Textures | Example</title>
    <link rel="stylesheet" type="text/css" href="examples/css/main.css">
    <script src="examples/jsm/stats.min.js"></script>
  </head>

  <body>

    <div class="container background">
      <div class="header"></div>
      <div class="content">
        <div id="canvas_container"></div>
      </div>
    </div>

    <script type="module">
      import { APP } from './examples/jsm/Main.js';
      import { PlaneGeometry } from './examples/jsm/three.module.js';

      const app = new APP();

      app.start();

      class WMSSource {
        constructor(config) {
          Object.assign(this, config);
          this.wms = this.wms + 'service=wms&version=1.3.0&request=getmap&layers={LAYER}&format=image/jpeg&crs={CRS}'
          this.wms = this.wms.replace('{LAYER}', config.layer);
          this.wms = this.wms.replace('{CRS}'  , config.crs  );
          const padding = this.tilePadding;
          const size = this.tileSize;
          const width = size[0]+2*padding;
          const height = size[1]+2*padding;
          this.wmsTile = this.wms+'&width='+width+'&height='+height+'&BBOX=';
          this.textures = [];
          const bbox = this.bbox;
          for(let i = 0; i < config.numTextures; ++i)
            this.textures[i] = this.url(size[0]<<i, size[1]<<i, bbox[0], bbox[1], bbox[2], bbox[3]);
        }
        url(width, height, x0, y0, x1, y1) {
          return this.wms+'&width='+width+'&height='+height+'&BBOX='+y0+','+x0+','+y1+','+x1;
        }
        getTilePath(tile) {
          const bbox = this.bbox;
          const padding = this.tilePadding;
          const size = this.tileSize;
          const w = (bbox[2]-bbox[0]) / (1 << tile.z);
          const h = (bbox[3]-bbox[1]) / (1 << tile.z);
          const x = bbox[0]+w*tile.x;
          const y = bbox[3]-h*tile.y;
          const a = w*padding/size[0];
          const b = h*padding/size[1];
          return { url: this.wmsTile+(y-h-b)+','+(x-a)+','+(y+b)+','+(x+w+a)};
        }
      }

      var config = [
        {
          maxMipMapLevel: 9,
          minMipMapLevel: 0,
          tileSize: [256,256],
          tilePadding: 0,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.25,
          getTilePath: function(tile) {
            let url = 'https://wxs.ign.fr/decouverte/geoportail/wmts?LAYER=ORTHOIMAGERY.ORTHOPHOTOS&FORMAT=image/jpeg&SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetTile&STYLE=normal&TILEMATRIXSET=PM&TILEMATRIX={Z}&TILEROW={Y}&TILECOL={X}';
            url = url.replace('{X}', tile.x);
            url = url.replace('{Y}', tile.y);
            url = url.replace('{Z}', tile.z);
            return { url };
          }
        },
        {
          maxMipMapLevel: 4,
          minMipMapLevel: 0,
          tileSize: [128,128],
          tilePadding: 4,
          tileClamp: 0.5,
          pageCount: [32,32],
          tileDeterminationRatio: 0.125,
          getTilePath: function(tile) {
            const directory = '/examples/models/terrain/tiles/diffuse/';
            const level = tile.z;
            const pageNumber = tile.x + tile.y * ( 1 << level );
            const filename = level + '-' + pageNumber + ".jpg";
            const url = directory + filename;
            return { url };
          }
        },
        {
          minMipMapLevel: 0,
          iip: 'https://wxs.ign.fr/x7yv499pbcguxhhxh8syehwe/iipsrv.fcgi',
          id: 'DEMAT.PVA/0317-0101/IGNF_PVA_1-0__1944__C0317-0101_1944_106G2481_4026.jp2',
          img_url: '{IIP}?FIF={ID}&LYR=20&JTL={JTL}',
          info_url: '{IIP}?FIF={ID}&obj=IIP,1.0&obj=Max-size&obj=Tile-size&obj=Resolution-number',
          tilePadding: 0,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.125,
          init: function() {
            const scope = this;
            const info_url = this.info_url.replace('{IIP}', this.iip).replace('{ID}', this.id);
            this.url = this.img_url.replace('{IIP}', this.iip).replace('{ID}', this.id);
            return fetch(info_url)
            .then((response) => response.text())
            .then((txt) => Object.fromEntries(txt.split(/\r?\n/)
              .map((line) => line.split(':'))
              .filter((line) => line.length == 2)
              .map((entry) => {
                const values = entry[1].split(/\s+/).map((v) => parseInt(v, 10));
                return [entry[0], values];
              })
            ))
            .then((info) => {
              scope.maxMipMapLevel = info['Resolution-number']-1;
              scope.tileSize = info['Tile-size'];
              scope.size = info['Max-size'];
              scope.numTiles = [];
              for(let z=0; z<=scope.maxMipMapLevel; ++z) {
                const TW = scope.tileSize[0] << (scope.maxMipMapLevel - z);
                const TH = scope.tileSize[1] << (scope.maxMipMapLevel - z);
                const W = Math.ceil(scope.size[0]/TW);
                const H = Math.ceil(scope.size[1]/TH);
                scope.numTiles[z] = [W, H];
              }
              scope.getTilePath = function(tile) {
                const W = scope.numTiles[tile.z][0];
                const H = scope.numTiles[tile.z][1];
                if ( tile.x >= W || tile.y >= H ) return null;
                const url = scope.url.replace('{JTL}', tile.z+','+(tile.x+W*tile.y));
                return { url };
              };
              return scope;
            });
          },
        },
        {
          minMipMapLevel: 0,
          iiif: 'http://134.158.75.67:8081',
          id: 'Niepce%2FGros%2F2003.15.676.15P01RB.jp2',
          img_url: '{IIIF}/{ID}/{region}/{size}/0/default.jpg',
          info_url: '{IIIF}/{ID}/info.json',
          tilePadding: 4,
          tileClamp: 0.5,
          tileSize: [256, 256],
          pageCount: [16,16],
          tileDeterminationRatio: 0.125,
          init: function() {
            const scope = this;
            const info_url = this.info_url
            .replace('{IIIF}', this.iiif)
            .replace('{ID}', this.id);
            this.url = this.img_url
            .replace('{IIIF}', this.iiif)
            .replace('{ID}', this.id);
            return fetch(info_url)
            .then((response) => response.json())
            .then((info) => {
              const tileCount = Math.ceil(Math.max(info.width/scope.tileSize[0], info.height/scope.tileSize[1]));
              scope.maxMipMapLevel = Math.ceil(Math.log2(tileCount));
              scope.size = [ info.width, info.height ];
              scope.numTiles = [];
              for(let z=0; z<=scope.maxMipMapLevel; ++z) {
                const TW = scope.tileSize[0] << (scope.maxMipMapLevel - z);
                const TH = scope.tileSize[1] << (scope.maxMipMapLevel - z);
                const W = Math.ceil(scope.size[0]/TW);
                const H = Math.ceil(scope.size[1]/TH);
                scope.numTiles[z] = [W, H];
              }
              scope.getTilePath = function(tile) {
                const W = scope.numTiles[tile.z][0];
                const H = scope.numTiles[tile.z][1];
                if ( tile.x >= W || tile.y >= H ) return null;
                const z = scope.maxMipMapLevel - tile.z;
                const w = scope.tileSize[0] << z;
                const h = scope.tileSize[1] << z;
                const pad = scope.tilePadding << z;
                const x = tile.x * w - pad;
                const y = tile.y * h - pad;
                const x0 = Math.max(x, 0);
                const y0 = Math.max(y, 0);
                const x1 = Math.min(x + w + 2*pad, scope.size[0]);
                const y1 = Math.min(y + h + 2*pad, scope.size[1]);
                const w0 = x1-x0;
                const h0 = y1-y0;
                const w1 = w0 >> z;
                const h1 = h0 >> z;

                const url = scope.url
                .replace('{region}', [x0,y0,w0,h0].join(','))
                .replace('{size}', [w1, h1].join(','));
                return { url, x0: (x0-x)>>z, y0:(y0-y)>>z };
              };
              console.log(scope);
              return scope;
            });
          },
        },
        new WMSSource({
          maxMipMapLevel: 7,
          minMipMapLevel: 0,
          tileSize: [256,256],
          tilePadding: 30,
          tileClamp: 0.5,
          pageCount: [16,16],
          tileDeterminationRatio: 0.1,
          numTextures: 5,
          wms: 'https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?',
          layer: 'gebco_latest',
          crs: 'EPSG:4326',
          bbox: [-10,40,15,55]
        }),
      ];

      var geometry = new PlaneGeometry(100, 100, 100);
      function start(conf) {
        app.load(geometry, conf);
        app.run();
        window.vt = app.virtualTexture;
      }

      const params = new URL(document.location).searchParams;
      const conf = config[parseInt(params.get("config")) || 0];
      if (conf.init) conf.init().then(start);
      else           start(conf);

    </script>
  </body>

  </head>
</html>
